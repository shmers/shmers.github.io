[
  {
    "objectID": "projects/pricing-risk.html",
    "href": "projects/pricing-risk.html",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "",
    "text": "This project demonstrates an endâ€‘toâ€‘end approach to designing, validating, and evaluating a predictive risk model in a pricing context. The focus is on modelling judgement, feature design, and validation rather than maximising headline performance metrics. Here Iâ€™ve intentionally generated a challenging synthetic dataset to demonstrate the modelling options available in typical insurance pricing contexts.\nDisclaimer to CMA: All data used in this project is fully synthetic (generated right before your very eyes, no less) and does not reflect any proprietary datasets."
  },
  {
    "objectID": "projects/pricing-risk.html#overview",
    "href": "projects/pricing-risk.html#overview",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "",
    "text": "This project demonstrates an endâ€‘toâ€‘end approach to designing, validating, and evaluating a predictive risk model in a pricing context. The focus is on modelling judgement, feature design, and validation rather than maximising headline performance metrics. Here Iâ€™ve intentionally generated a challenging synthetic dataset to demonstrate the modelling options available in typical insurance pricing contexts.\nDisclaimer to CMA: All data used in this project is fully synthetic (generated right before your very eyes, no less) and does not reflect any proprietary datasets."
  },
  {
    "objectID": "projects/pricing-risk.html#problem-statement",
    "href": "projects/pricing-risk.html#problem-statement",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "Problem Statement",
    "text": "Problem Statement\nWe consider a hypothetical insuranceâ€‘style problem where the goal is to predict the probability of a highâ€‘cost loss event for individual policies, based on customer, asset, and contextual features.\nKey challenges include:\n\nClass imbalance\nFeature leakage\nModel interpretability vs performance tradeâ€‘offs"
  },
  {
    "objectID": "projects/pricing-risk.html#data-generation",
    "href": "projects/pricing-risk.html#data-generation",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "Data Generation",
    "text": "Data Generation\nWe generate a synthetic dataset designed to capture common characteristics of realâ€‘world consumer risk portfolios:\n\nSkewed loss distribution\nCorrelated features\nRare but severe outcomes\n\n\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(123)\n\nn = 20000\n\ndata = pd.DataFrame({\n    \"vehicle_value\": np.random.lognormal(mean=10, sigma=0.5, size=n),\n    \"driver_age\": np.random.randint(18, 80, size=n),\n    \"annual_mileage\": np.random.gamma(shape=2, scale=6000, size=n),\n    \"urban_density\": np.random.beta(2, 5, size=n),\n    \"prior_claims\": np.random.poisson(0.3, size=n)\n})\n\nlogit = (\n    -7.0\n    + 0.000002 * data[\"vehicle_value\"]\n    - 0.015 * data[\"driver_age\"]\n    + 0.00004 * data[\"annual_mileage\"]\n    + 1.5 * data[\"urban_density\"]\n    + 0.6 * data[\"prior_claims\"]\n)\n\nprob = 1 / (1 + np.exp(-logit))\ndata[\"high_cost_claim\"] = np.random.binomial(1, prob)\n\ndata.head()\n\n\n\n\n\n\n\n\nvehicle_value\ndriver_age\nannual_mileage\nurban_density\nprior_claims\nhigh_cost_claim\n\n\n\n\n0\n12799.798382\n69\n3883.837719\n0.171791\n0\n0\n\n\n1\n36267.333927\n26\n17499.414406\n0.065992\n0\n0\n\n\n2\n25374.226904\n54\n5726.365121\n0.222687\n1\n0\n\n\n3\n10371.870313\n78\n10299.632113\n0.683120\n0\n0\n\n\n4\n16493.140959\n74\n1743.097292\n0.366287\n0\n0"
  },
  {
    "objectID": "projects/pricing-risk.html#feature-engineering",
    "href": "projects/pricing-risk.html#feature-engineering",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "Feature Engineering",
    "text": "Feature Engineering\nWeâ€™ll keep feature engineering very basic here, banding features for interpretability and stability, with transformations / interactions chosen to reflect common approaches used in pricing and risk models, rather than going for model complexity straight away.\nKey considerations include: - Handling heavyâ€‘tailed distributions - Capturing nonâ€‘linear effects - Maintaining transparency for downstream stakeholders\n\nimport numpy as np\nimport pandas as pd\n\ndf = data.copy()\n\n# Log-transform heavy-tailed monetary values\ndf[\"log_vehicle_value\"] = np.log(df[\"vehicle_value\"])\n\n# Mileage exposure bands\ndf[\"mileage_band\"] = pd.cut(\n    df[\"annual_mileage\"],\n    bins=[0, 5000, 10000, 15000, 25000, np.inf],\n    labels=False\n)\n\n# Age bands to capture non-linear risk patterns\ndf[\"age_band\"] = pd.cut(\n    df[\"driver_age\"],\n    bins=[17, 25, 35, 50, 65, 100],\n    labels=False\n)\n\n# Interaction: high value asset in dense urban areas\ndf[\"urban_value_interaction\"] = (\n    df[\"urban_density\"] * df[\"log_vehicle_value\"]\n)\n\nengineered_features = [\n    \"log_vehicle_value\",\n    \"mileage_band\",\n    \"age_band\",\n    \"urban_density\",\n    \"prior_claims\",\n    \"urban_value_interaction\"\n]\n\nX = df[engineered_features]\ny = df[\"high_cost_claim\"]\n\nX.head()\n\n\n\n\n\n\n\n\nlog_vehicle_value\nmileage_band\nage_band\nurban_density\nprior_claims\nurban_value_interaction\n\n\n\n\n0\n9.457185\n0\n4\n0.171791\n0\n1.624659\n\n\n1\n10.498673\n3\n1\n0.065992\n0\n0.692828\n\n\n2\n10.141489\n1\n3\n0.222687\n1\n2.258378\n\n\n3\n9.246853\n2\n4\n0.683120\n0\n6.316712\n\n\n4\n9.710700\n0\n4\n0.366287\n0\n3.556906"
  },
  {
    "objectID": "projects/pricing-risk.html#modelling-approach",
    "href": "projects/pricing-risk.html#modelling-approach",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "Modelling Approach",
    "text": "Modelling Approach\nAs a baseline, letâ€™s fit a logistic regression model using the engineered features. Logistic regression provides a transparent and wellâ€‘understood benchmark, allowing coefficientâ€‘level interpretation and serving as a reference point for more complex models later on.\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import roc_auc_score\n\n# Train / test split\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.3, random_state=42, stratify=y\n)\n\n# Standardise features for logistic regression\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n\n# Fit model\nlog_reg = LogisticRegression(max_iter=1000)\nlog_reg.fit(X_train_scaled, y_train)\n\n# Predict probabilities\ny_pred_proba = log_reg.predict_proba(X_test_scaled)[:, 1]\n\nroc_auc = roc_auc_score(y_test, y_pred_proba)\nroc_auc\n\n0.6906500333778371\n\n\nTo contextualise this value, itâ€™s worth bearing in mind that random guessing would achieve an ROC AUC of 0.50, 0.70+ would indicate strong separation, and 1.0 a perfect model.\nOur value shows that the model could be stronger, but is still better than random. In a real insurance context we would have at least a few different options to explore here to improve the model:\n\nNonâ€‘linear effects\nInteraction terms\nBehavioural history depth\nLatent segments\n\nâ€¦ but we donâ€™t want to end up turning this scenario into a toy problem; this isnâ€™t Kaggle.\nLetâ€™s keep the focus on evaluation and calibration, as weâ€™re not interested in maximising performance just yet, weâ€™ll save that fun for later when we see what gradient boosting can do."
  },
  {
    "objectID": "projects/pricing-risk.html#coefficient-interpretation",
    "href": "projects/pricing-risk.html#coefficient-interpretation",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "Coefficient Interpretation",
    "text": "Coefficient Interpretation\nInspecting model coefficients quickly helps us validate whether learned relationships align with domain expectations.\n\ncoef_df = pd.DataFrame({\n    \"feature\": engineered_features,\n    \"coefficient\": log_reg.coef_[0]\n}).sort_values(by=\"coefficient\", ascending=False)\n\ncoef_df\n\n\n\n\n\n\n\n\nfeature\ncoefficient\n\n\n\n\n4\nprior_claims\n0.524268\n\n\n1\nmileage_band\n0.360799\n\n\n3\nurban_density\n0.180719\n\n\n5\nurban_value_interaction\n0.175511\n\n\n0\nlog_vehicle_value\n0.089934\n\n\n2\nage_band\n-0.291732\n\n\n\n\n\n\n\nObviously since we created the label ourselves using a logit distribution weâ€™re not surprised to see the original coefficient values reflected here in the logistic regression model. In reality at this stage of modelling we wouldnâ€™t be expecting to deduce anything profound yet from an unsophisticated view such as this, but we might opt to construct a rough-and-ready feedback loop with our feature engineering choices for rapid prototyping.\nIn my experience this type of feedback loop can pay dividends for improving the efficacy of engineered features without too much additional time or resource, and works especially well when the chosen evaluation metrics are thoughtfully chosen, such as measures of marginal predictive skill contribution / model uplift on a feature level basis."
  },
  {
    "objectID": "projects/pricing-risk.html#validation-and-calibration",
    "href": "projects/pricing-risk.html#validation-and-calibration",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "Validation and Calibration",
    "text": "Validation and Calibration\nIn riskâ€‘based decision systems, wellâ€‘calibrated probabilities are often as important as ranking performance. We therefore examine calibration behaviour alongside discrimination metrics.\n\nfrom sklearn.calibration import calibration_curve\nimport matplotlib.pyplot as plt\n\nprob_true, prob_pred = calibration_curve(\n    y_test,\n    y_pred_proba,\n    n_bins=10,\n    strategy=\"quantile\"\n)\n\nplt.figure(figsize=(6, 6))\nplt.plot(prob_pred, prob_true, marker=\"o\", label=\"Model\")\nplt.plot([0, 1], [0, 1], linestyle=\"--\", label=\"Perfect calibration\")\nplt.xlabel(\"Predicted probability\")\nplt.ylabel(\"Observed frequency\")\nplt.title(\"Calibration Curve\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nNot much to see here, it seemsâ€¦ Weâ€™ve chosen a difficult problem to model, that of a rare-event setting, such as a large 3rd party BI claim in UK motor insurance. Letâ€™s see how far weâ€™d need to zoom in to see whatâ€™s going on.\n\nHistogram of probabilities\n\nplt.figure(figsize=(6, 4))\nplt.hist(y_pred_proba, bins=50)\nplt.xlabel(\"Predicted probability\")\nplt.ylabel(\"Count\")\nplt.title(\"Distribution of Predicted Probabilities\")\nplt.show()\n\n\n\n\n\n\n\n\nSo looks like probabilities are only significantly allocated between 0% and 1%\n\nZoomed in to 0 - 1%\n\nplt.figure(figsize=(6, 6))\nplt.plot(prob_pred, prob_true, marker=\"o\", label=\"Model\")\nplt.plot([0, 0.1], [0, 0.1], linestyle=\"--\", label=\"Perfect calibration\")\n\nplt.xlim(0, 0.01)\nplt.ylim(0, 0.01)\n\nplt.xlabel(\"Predicted probability\")\nplt.ylabel(\"Observed frequency\")\nplt.title(\"Calibration Curve (Zoomed: 0â€“1%)\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nThe calibration curve assesses whether predicted probabilities correspond to observed event frequencies. Predictions that lie close to the diagonal indicate wellâ€‘calibrated probabilities, while systematic deviations highlight overâ€‘ or underâ€‘confidence.\nIn rareâ€‘event settings, calibration at higher predicted probabilities can be noisy due to limited sample sizes. Nevertheless, this analysis provides important insight into whether predicted risks are suitable for downstream decisionâ€‘making or require postâ€‘hoc calibration.\nHere we can see that the model seems passable at assigning probabilities that arenâ€™t too far off of the mark, generally speaking. If we had grouped more aggressively we might not see as much noise, but I tend to prefer erring on the side of seeing the noise and reassuring myself that it truly is noise, and not a systematic calibration error that may need further thought. Here the points seem fairly randomly distributed around the perfect calibration line, so no strong need for post-hoc calibration necessarily yet, but thereâ€™s more we can do to answer this concern.\n\n\nBrier Score\nThe Brier score is defined as $ (p_i - y_i)^2 $ averaged over observations. In other words the average squared error in the predicted probabilities.\nThe Brier score is a proper scoring rule that measures the accuracy of probabilistic predictions. For a binary outcome, it is defined as:\n\\[\n\\text{Brier Score} = \\frac{1}{N} \\sum_{i=1}^{N} (p_i - y_i)^2\n\\]\nwhere \\(p_i\\) is the predicted probability of the event and \\(y_i\\) is the observed outcome.\n\nfrom sklearn.metrics import brier_score_loss\n\nbrier = brier_score_loss(y_test, y_pred_proba)\nbrier\n\n0.0013324230061909923\n\n\nLower Brier scores indicate better overall probability accuracy, penalising both overâ€‘confident and underâ€‘confident predictions. Unlike ROCâ€‘AUC, the Brier score directly reflects the quality of predicted probabilities, making it particularly relevant in riskâ€‘based decision systems.\nAlthough this value looks fairly low in absolute terms, letâ€™s bear in mind that weâ€™ll need to check against a logical benchmark to know how good a score this is, and whether we should be reassured or alarmed at its value.\n\n\n\nBrier Skill Score\nInterpreting the Brier Score is easier with a relative measure like the Brier Skill Score (BSS), which measures the improvement in probabilistic accuracy relative to a reference forecast. It is defined as:\n\\[\n\\text{BSS} = 1 - \\frac{\\text{Brier}_{\\text{model}}}{\\text{Brier}_{\\text{ref}}}\n\\]\nIn this example, the reference forecast is a constant baseâ€‘rate model that predicts the empirical event rate for all observations. For rare event scenarios such as the synthetically generated dataset weâ€™re looking at, this is somewhat difficult to beat, so letâ€™s see how we did:\n\nimport numpy as np\nfrom sklearn.metrics import brier_score_loss\n\n# Reference forecast: base rate\nbase_rate = y_train.mean()\ny_ref = np.full_like(y_test, fill_value=base_rate, dtype=float)\n\nbrier_ref = brier_score_loss(y_test, y_ref)\nbrier_model = brier_score_loss(y_test, y_pred_proba)\n\nbrier_skill_score = 1 - (brier_model / brier_ref)\nbrier_skill_score\n\n-0.0006497525279884897\n\n\nA positive Brier Skill Score indicates that the model improves probabilistic accuracy relative to the baseâ€‘rate benchmark. Negative means weâ€™re predicting worse than the default base-rate prediction. The Brier Skill Score contextualises absolute probability error by comparing against a naive baseline. In rareâ€‘event problems, even modest positive skill represents meaningful improvement over baseâ€‘rate forecasting.\nHowever, itâ€™s important to note that a negative Brier Skill Score does not necessarily mean the model is performing badly. Just that it is not yet calibrated properly. Earlier we saw an okay ROC AUC value, so letâ€™s consider post-hoc calibration options to see whether we can optimise our probabilities without deteriorating the ranking performance that we were otherwise happy with."
  },
  {
    "objectID": "projects/pricing-risk.html#posthoc-calibration-comparison",
    "href": "projects/pricing-risk.html#posthoc-calibration-comparison",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "Postâ€‘Hoc Calibration Comparison",
    "text": "Postâ€‘Hoc Calibration Comparison\nTo assess whether probability calibration improves probabilistic accuracy, we compare the uncalibrated model against two postâ€‘hoc calibration approaches: Platt scaling and isotonic regression.\n\nfrom sklearn.calibration import CalibratedClassifierCV\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import brier_score_loss\nimport pandas as pd\n\n# Base model (same specification)\nbase_model = LogisticRegression(max_iter=1000)\n\n# Platt scaling (sigmoid)\nplatt_model = CalibratedClassifierCV(\n    base_model,\n    method=\"sigmoid\",\n    cv=5\n)\n\n# Isotonic calibration\nisotonic_model = CalibratedClassifierCV(\n    base_model,\n    method=\"isotonic\",\n    cv=5\n)\n\n# Fit calibrated models\nplatt_model.fit(X_train_scaled, y_train)\nisotonic_model.fit(X_train_scaled, y_train)\n\n# Predict probabilities\ny_platt = platt_model.predict_proba(X_test_scaled)[:, 1]\ny_isotonic = isotonic_model.predict_proba(X_test_scaled)[:, 1]\n\n# Base-rate reference\nbase_rate = y_train.mean()\ny_ref = np.full_like(y_test, base_rate, dtype=float)\n\n# Compute Brier scores\nresults = pd.DataFrame({\n    \"Model\": [\"Uncalibrated\", \"Platt scaling\", \"Isotonic\"],\n    \"Brier score\": [\n        brier_score_loss(y_test, y_pred_proba),\n        brier_score_loss(y_test, y_platt),\n        brier_score_loss(y_test, y_isotonic)\n    ]\n})\n\nresults\n\n\n\n\n\n\n\n\nModel\nBrier score\n\n\n\n\n0\nUncalibrated\n0.001332\n\n\n1\nPlatt scaling\n0.001331\n\n\n2\nIsotonic\n0.001331\n\n\n\n\n\n\n\n\nCompute Brier Skill scores\n\nresults[\"Brier Skill Score\"] = 1 - (\n    results[\"Brier score\"] / brier_score_loss(y_test, y_ref)\n)\n\nresults\n\n\n\n\n\n\n\n\nModel\nBrier score\nBrier Skill Score\n\n\n\n\n0\nUncalibrated\n0.001332\n-0.000650\n\n\n1\nPlatt scaling\n0.001331\n0.000286\n\n\n2\nIsotonic\n0.001331\n0.000217\n\n\n\n\n\n\n\nPostâ€‘hoc calibration improves probability scaling relative to the uncalibrated model, reducing overall Brier score. We can see here that both Platt scaling and Isotonic calibration improved our Brier Skill score into a slight positive result, from negative originally. This confirms our suspicion that our model probabilities were suffering from a calibration issue. Letâ€™s redraw our calibration curve and see the difference."
  },
  {
    "objectID": "projects/pricing-risk.html#calibration-curves-before-and-after-calibration",
    "href": "projects/pricing-risk.html#calibration-curves-before-and-after-calibration",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "Calibration Curves: Before and After Calibration",
    "text": "Calibration Curves: Before and After Calibration\nTo visualise the effect of postâ€‘hoc calibration, we compare calibration curves for the uncalibrated model and the calibrated variants. Given the rarity of the event, the plot focuses on the probability range where most predictions lie.\n\nfrom sklearn.calibration import calibration_curve\nimport matplotlib.pyplot as plt\n\n# Compute calibration curves\nprob_true_uncal, prob_pred_uncal = calibration_curve(\n    y_test, y_pred_proba, n_bins=5, strategy=\"quantile\"\n)\n\nprob_true_platt, prob_pred_platt = calibration_curve(\n    y_test, y_platt, n_bins=5, strategy=\"quantile\"\n)\n\nprob_true_iso, prob_pred_iso = calibration_curve(\n    y_test, y_isotonic, n_bins=5, strategy=\"quantile\"\n)\n\n# Plot\nplt.figure(figsize=(7, 7))\n\nplt.plot(prob_pred_uncal, prob_true_uncal, marker=\"o\", label=\"Uncalibrated\")\nplt.plot(prob_pred_platt, prob_true_platt, marker=\"o\", label=\"Platt scaling\")\nplt.plot(prob_pred_iso, prob_true_iso, marker=\"o\", label=\"Isotonic\")\n\n# Perfect calibration reference\nplt.plot([0, 0.005], [0, 0.005], linestyle=\"--\", color=\"black\", label=\"Perfect calibration\")\n\n# Zoomed axes for rare-event setting\nplt.xlim(0, 0.005)\nplt.ylim(0, 0.005)\n\nplt.xlabel(\"Predicted probability\")\nplt.ylabel(\"Observed frequency\")\nplt.title(\"Calibration Curves (Zoomed: 0â€“0.5%)\")\nplt.legend()\nplt.grid(alpha=0.3)\nplt.show()\n\n\n\n\n\n\n\n\nPostâ€‘hoc calibration improves the alignment between predicted probabilities and observed event frequencies. Platt scaling provides a smooth adjustment that improves probability reliability, while isotonic calibration offers greater flexibility at the cost of increased variance in sparse regions. In rareâ€‘event settings, these tradeâ€‘offs must be balanced thoughtfully."
  },
  {
    "objectID": "projects/pricing-risk.html#todo---gradient-boosting",
    "href": "projects/pricing-risk.html#todo---gradient-boosting",
    "title": "Designing a Predictive Risk Model for High-Value Assets",
    "section": "Todo - Gradient Boosting",
    "text": "Todo - Gradient Boosting"
  },
  {
    "objectID": "projects/geospatial-risk.html",
    "href": "projects/geospatial-risk.html",
    "title": "Incorporating Geospatial Context into Risk Modelling",
    "section": "",
    "text": "This project demonstrates how geospatial context can be incorporated into predictive risk models using aggregated, nonâ€‘identifying spatial features. The emphasis is on feature construction, spatial smoothing, and avoiding information leakage rather than on fineâ€‘grained location data.\nAll data used in this project is synthetic or publicly available."
  },
  {
    "objectID": "projects/geospatial-risk.html#overview",
    "href": "projects/geospatial-risk.html#overview",
    "title": "Incorporating Geospatial Context into Risk Modelling",
    "section": "",
    "text": "This project demonstrates how geospatial context can be incorporated into predictive risk models using aggregated, nonâ€‘identifying spatial features. The emphasis is on feature construction, spatial smoothing, and avoiding information leakage rather than on fineâ€‘grained location data.\nAll data used in this project is synthetic or publicly available."
  },
  {
    "objectID": "projects/geospatial-risk.html#problem-statement",
    "href": "projects/geospatial-risk.html#problem-statement",
    "title": "Incorporating Geospatial Context into Risk Modelling",
    "section": "Problem Statement",
    "text": "Problem Statement\nWe consider a hypothetical risk prediction problem where event likelihood varies spatially due to underlying environmental, behavioural, or socioâ€‘economic factors. The goal is to construct geospatial features that capture this variation in a stable and privacyâ€‘preserving way.\nKey challenges include:\n\nSpatial leakage\nSparsity in fineâ€‘grained locations\nBalancing resolution with robustness"
  },
  {
    "objectID": "projects/geospatial-risk.html#synthetic-spatial-data",
    "href": "projects/geospatial-risk.html#synthetic-spatial-data",
    "title": "Incorporating Geospatial Context into Risk Modelling",
    "section": "Synthetic Spatial Data",
    "text": "Synthetic Spatial Data\n\nimport numpy as np\nimport pandas as pd\n\nnp.random.seed(123)\n\nn = 20000\n\n# Synthetic latitude / longitude (approximate UK bounding box)\nlat = np.random.uniform(50.0, 55.5, n)\nlon = np.random.uniform(-5.5, 1.8, n)\n\ndf = pd.DataFrame({\n    \"latitude\": lat,\n    \"longitude\": lon\n})\n\ndf.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\n\n\n\n\n0\n53.830581\n-4.868714\n\n\n1\n51.573766\n-1.235600\n\n\n2\n51.247683\n-2.048911\n\n\n3\n53.032231\n-0.370855\n\n\n4\n53.957079\n-2.130276"
  },
  {
    "objectID": "projects/geospatial-risk.html#create-spatial-clusters-of-higher-risk",
    "href": "projects/geospatial-risk.html#create-spatial-clusters-of-higher-risk",
    "title": "Incorporating Geospatial Context into Risk Modelling",
    "section": "Create spatial clusters of higher risk",
    "text": "Create spatial clusters of higher risk\n\nrisk_centers = [\n    (51.5, -0.1),   # London\n    (53.5, -2.3),   # Manchester\n    (52.5, -1.9)    # Birmingham\n]\n\nrisk = np.zeros(n)\n\nfor lat_c, lon_c in risk_centers:\n    dist = np.sqrt((df[\"latitude\"] - lat_c)**2 + (df[\"longitude\"] - lon_c)**2)\n    risk += np.exp(-dist / 0.5)\n\n# Normalise\nrisk = risk / risk.max()\n\ndf[\"spatial_risk\"] = risk\n\ndf.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\nspatial_risk\n\n\n\n\n0\n53.830581\n-4.868714\n0.006423\n\n\n1\n51.573766\n-1.235600\n0.195246\n\n\n2\n51.247683\n-2.048911\n0.099452\n\n\n3\n53.032231\n-0.370855\n0.092219\n\n\n4\n53.957079\n-2.130276\n0.387473"
  },
  {
    "objectID": "projects/geospatial-risk.html#event-generation",
    "href": "projects/geospatial-risk.html#event-generation",
    "title": "Incorporating Geospatial Context into Risk Modelling",
    "section": "Event Generation",
    "text": "Event Generation\n\nlogit = -4.0 + 2.0 * df[\"spatial_risk\"]\nprob = 1 / (1 + np.exp(-logit))\n\ndf[\"event\"] = np.random.binomial(1, prob)\n\ndf[\"event\"].mean()\n\nnp.float64(0.02315)"
  },
  {
    "objectID": "projects/geospatial-risk.html#wip---visualisation",
    "href": "projects/geospatial-risk.html#wip---visualisation",
    "title": "Incorporating Geospatial Context into Risk Modelling",
    "section": "WIP - Visualisation",
    "text": "WIP - Visualisation"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "Outside of work, I enjoy chess, music, and endurance sports. I find these interests complement analytical work by encouraging longâ€‘term thinking, focus, and resilience.\nIâ€™m a 3d printing enthusiast, speculative fiction reader, and devoted cat dad.\nDuring my 2025 career break Iâ€™ve also become an amateur android app developer (so far for brain training apps and logic / puzzle games)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Morris Jones",
    "section": "",
    "text": "I am a senior data scientist with over 10 years of experience designing, validating, and deploying predictive models in production environments. My background spans insurance, reinsurance, and financial services, with a focus on risk modelling, probability estimation, and dataâ€‘driven decisionâ€‘making under uncertainty.\nThis site presents a selection of IPâ€‘safe, selfâ€‘contained demonstration projects that illustrate my approach to modelling, evaluation, and communication."
  },
  {
    "objectID": "index.html#senior-data-scientist",
    "href": "index.html#senior-data-scientist",
    "title": "Morris Jones",
    "section": "",
    "text": "I am a senior data scientist with over 10 years of experience designing, validating, and deploying predictive models in production environments. My background spans insurance, reinsurance, and financial services, with a focus on risk modelling, probability estimation, and dataâ€‘driven decisionâ€‘making under uncertainty.\nThis site presents a selection of IPâ€‘safe, selfâ€‘contained demonstration projects that illustrate my approach to modelling, evaluation, and communication."
  },
  {
    "objectID": "index.html#areas-of-focus",
    "href": "index.html#areas-of-focus",
    "title": "Morris Jones",
    "section": "Areas of Focus",
    "text": "Areas of Focus\n\nPredictive risk and pricing models\n\nRareâ€‘event modelling and probability calibration\n\nModel validation, monitoring, and governance\n\nApplied machine learning in regulated environments"
  },
  {
    "objectID": "index.html#featured-project",
    "href": "index.html#featured-project",
    "title": "Morris Jones",
    "section": "Featured Project",
    "text": "Featured Project\n\nDesigning a Predictive Risk Model for Highâ€‘Value Assets\nAn endâ€‘toâ€‘end demonstration of a rareâ€‘event risk modelling workflow, covering:\n\nSynthetic data generation\nDomainâ€‘informed feature engineering\nBaseline modelling and interpretation\nCalibration, Brier score, and Brier Skill Score\nPostâ€‘hoc probability calibration\n\nðŸ‘‰ View project"
  },
  {
    "objectID": "index.html#get-in-touch",
    "href": "index.html#get-in-touch",
    "title": "Morris Jones",
    "section": "Get in Touch",
    "text": "Get in Touch\nIf youâ€™re interested in discussing senior data science opportunities or would like to talk through any of the work shown here, feel free to get in touch.\n\nðŸ“§ morris.jones123@gmail.com\nðŸ”— GitHub"
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Projects",
    "section": "",
    "text": "Below is a selection of selfâ€‘contained, IPâ€‘safe demonstration projects showcasing my approach to data science, modelling, and decisionâ€‘making in productionâ€‘style contexts.\n\nDesigning a Predictive Risk Model for Highâ€‘Value Assets\nGeospatial Enhancements to Risk Modelling"
  }
]