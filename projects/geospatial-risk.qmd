---
title: "Incorporating Geospatial Context into Risk Modelling"
---

## Overview

This project demonstrates how geospatial context can be incorporated into predictive risk models using aggregated, non‑identifying spatial features. The emphasis is on feature construction, spatial smoothing, and avoiding information leakage rather than on fine‑grained location data.

All data used in this project is synthetic or publicly available.

---

## Problem Statement

We consider a hypothetical risk prediction problem where event likelihood varies spatially due to underlying environmental, behavioural, or socio‑economic factors. The goal is to construct geospatial features that capture this variation in a stable and privacy‑preserving way.

Key challenges include:

* Spatial leakage
* Sparsity in fine‑grained locations
* Balancing resolution with robustness

---

## Synthetic Spatial Data

```{python}
import numpy as np
import pandas as pd

np.random.seed(123)

n = 20000

# Synthetic latitude / longitude (approximate UK bounding box)
lat = np.random.uniform(50.0, 55.5, n)
lon = np.random.uniform(-5.5, 1.8, n)

df = pd.DataFrame({
    "latitude": lat,
    "longitude": lon
})

df.head()
```
---

## Create spatial clusters of higher risk

```{python}
risk_centers = [
    (51.5, -0.1),   # London
    (53.5, -2.3),   # Manchester
    (52.5, -1.9)    # Birmingham
]

risk = np.zeros(n)

for lat_c, lon_c in risk_centers:
    dist = np.sqrt((df["latitude"] - lat_c)**2 + (df["longitude"] - lon_c)**2)
    risk += np.exp(-dist / 0.5)

# Normalise
risk = risk / risk.max()

df["spatial_risk"] = risk

df.head()
```

---

## Event Generation

```{python}
logit = -4.0 + 2.0 * df["spatial_risk"]
prob = 1 / (1 + np.exp(-logit))

df["event"] = np.random.binomial(1, prob)

df["event"].mean()
```

---

## Spatial Binning

To incorporate spatial context in a robust and privacy‑preserving way, we discretise latitude and longitude into coarse spatial bins. This reduces sensitivity to exact coordinates while enabling aggregation of local risk signals.

```{python}
# Define bin sizes (degrees)
lat_bin_size = 0.25
lon_bin_size = 0.25

df["lat_bin"] = (df["latitude"] / lat_bin_size).astype(int)
df["lon_bin"] = (df["longitude"] / lon_bin_size).astype(int)

# Combine into a single spatial cell identifier
df["spatial_cell"] = df["lat_bin"].astype(str) + "_" + df["lon_bin"].astype(str)

df[["latitude", "longitude", "spatial_cell"]].head()
```

---

## Spatial Aggregation

Within each spatial cell, we compute aggregated statistics that summarise local event behaviour. These aggregates form the basis of geospatial risk features.

```{python}
cell_stats = (
    df.groupby("spatial_cell")
      .agg(
          cell_event_rate=("event", "mean"),
          cell_event_count=("event", "sum"),
          cell_exposure=("event", "count")
      )
      .reset_index()
)

cell_stats.head()
```

---



## Smoothing Sparse Spatial Estimates

Raw cell event rates can be **noisy** when exposure is low.  
We’ll apply **empirical Bayes–style smoothing**.

To reduce variance in low‑exposure cells, we apply simple Bayesian smoothing by shrinking cell‑level event rates toward the global mean.

```{python}
# Global event rate
global_rate = df["event"].mean()

# Smoothing strength (pseudo-counts)
alpha = 50

cell_stats["smoothed_event_rate"] = (
    (cell_stats["cell_event_rate"] * cell_stats["cell_exposure"] + alpha * global_rate)
    / (cell_stats["cell_exposure"] + alpha)
)

cell_stats.head()
```

---

## Constructing Geospatial Features

We attach the aggregated spatial features back to the individual‑level dataset for use in downstream modelling.

```{python}
df = df.merge(
    cell_stats[["spatial_cell", "smoothed_event_rate"]],
    on="spatial_cell",
    how="left"
)

df[["latitude", "longitude", "smoothed_event_rate"]].head()
```

---

```{python}
from shapely.geometry import Point
import geopandas as gpd

geometry = [
    Point(lon, lat)
    for lon, lat in zip(df["longitude"], df["latitude"])
]

gdf = gpd.GeoDataFrame(df, geometry=geometry, crs="EPSG:4326")
gdf_bng = gdf.to_crs(epsg=27700)
```

---

## Visualising Raw Spatial Events

We begin by visualising the spatial distribution of events to understand broad geographic patterns and clustering behaviour.

```{python}
import matplotlib.pyplot as plt

plt.figure(figsize=(7, 7))

plt.scatter(
    df["longitude"],
    df["latitude"],
    c=df["event"],
    cmap="coolwarm",
    alpha=0.3,
    s=10
)

plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("Spatial Distribution of Events")
plt.colorbar(label="Event indicator")
plt.show()
```

---

## Visualising Smoothed Spatial Risk

Aggregated and smoothed spatial features provide a clearer view of underlying geographic risk patterns.

```{python}
# Use cell-level centroids for plotting
cell_stats["lat_center"] = (
    cell_stats["spatial_cell"]
    .str.split("_")
    .str[0]
    .astype(int) * lat_bin_size
)

cell_stats["lon_center"] = (
    cell_stats["spatial_cell"]
    .str.split("_")
    .str[1]
    .astype(int) * lon_bin_size
)

plt.figure(figsize=(7, 7))

plt.scatter(
    cell_stats["lon_center"],
    cell_stats["lat_center"],
    c=cell_stats["smoothed_event_rate"],
    cmap="viridis",
    s=cell_stats["cell_exposure"] / 5,
    alpha=0.8
)

plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("Smoothed Spatial Risk by Grid Cell")
plt.colorbar(label="Smoothed event rate")
plt.show()
```

Comparing individual‑level and aggregated spatial visualisations highlights the trade‑off between noise and signal. While raw location data is highly variable, spatial aggregation and smoothing reveal stable geographic patterns suitable for use in predictive models.

---

## Thiessen (Voronoi) Polygons for Spatial Risk

To further visualise spatial structure, we construct Thiessen (Voronoi) polygons based on spatial cell centroids. Each polygon represents the region of space closest to a given cell, providing a continuous spatial partition coloured by smoothed risk.

For the curious, click here to learn more about [Voronoi polygons](https://en.wikipedia.org/wiki/Voronoi_diagram)

```{python}
import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import Voronoi

# Prepare centroid coordinates
points = np.column_stack([
    cell_stats["lon_center"].values,
    cell_stats["lat_center"].values
])

# Compute Voronoi tessellation
vor = Voronoi(points)

# Plot
plt.figure(figsize=(8, 8))

# Plot Voronoi regions
for region_index, region in enumerate(vor.regions):
    if not region or -1 in region:
        continue  # Skip infinite regions

    polygon = [vor.vertices[i] for i in region]
    polygon = np.array(polygon)

    # Find corresponding point index
    point_indices = np.where(vor.point_region == region_index)[0]
    if len(point_indices) == 0:
        continue

    idx = point_indices[0]
    risk_value = cell_stats.iloc[idx]["smoothed_event_rate"]

    plt.fill(
        polygon[:, 0],
        polygon[:, 1],
        color=plt.cm.viridis(risk_value / cell_stats["smoothed_event_rate"].max()),
        alpha=0.8
    )

# Overlay centroids
plt.scatter(
    cell_stats["lon_center"],
    cell_stats["lat_center"],
    c="black",
    s=10,
    alpha=0.6
)

plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("Thiessen (Voronoi) Polygons Coloured by Smoothed Risk")
plt.show()
```

---

## Mapping Spatial Risk Using the British National Grid

To visualise spatial risk in a cartographically appropriate coordinate system, we project locations onto the British National Grid (BNG). This projection is commonly used for mapping and spatial analysis within Great Britain, providing distance‑preserving coordinates in metres.

Northern Ireland uses a separate national grid and is therefore excluded from this visualisation for technical correctness.

```{python}
import geopandas as gpd
from shapely.geometry import Point

# Load Natural Earth country boundaries (110m resolution)
url = "https://naturalearth.s3.amazonaws.com/110m_cultural/ne_110m_admin_0_countries.zip"

world = gpd.read_file(url)

# Extract United Kingdom
uk = world[world["NAME"] == "United Kingdom"]

uk
```

---

```{python}
# Convert point data to GeoDataFrame
geometry = [
    Point(lon, lat)
    for lon, lat in zip(df["longitude"], df["latitude"])
]

gdf = gpd.GeoDataFrame(df, geometry=geometry, crs="EPSG:4326")

# Reproject to British National Grid (EPSG:27700)
uk_bng = uk.to_crs(epsg=27700)

uk_bng
```

## Keep only Great Britain (approximate longitude filter)
```{python}
uk_gb = uk[uk.geometry.centroid.x > -8]

uk_gb_bng = uk_gb.to_crs(epsg=27700)
```

---

```{python}
from shapely.geometry import Point
import geopandas as gpd

geometry = [
    Point(lon, lat)
    for lon, lat in zip(df["longitude"], df["latitude"])
]

gdf = gpd.GeoDataFrame(df, geometry=geometry, crs="EPSG:4326")
gdf_bng = gdf.to_crs(epsg=27700)

gdf_bng.head()
```


---

```{python}
import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(8, 10))

# Set subtle background colour
ax.set_facecolor("#f0f0f0")

# Plot spatial risk points first
gdf_bng.plot(
    ax=ax,
    column="smoothed_event_rate",
    cmap="viridis",
    markersize=5,
    alpha=0.7,
    legend=True
)

# Plot GB boundary ON TOP as white outline
uk_gb_bng.plot(
    ax=ax,
    facecolor="none",
    edgecolor="white",
    linewidth=1.5
)

ax.set_title("Smoothed Spatial Risk (British National Grid, Great Britain)")
ax.set_xlabel("Easting (m)")
ax.set_ylabel("Northing (m)")

plt.show()
```

---

Country boundaries are sourced from Natural Earth (public domain) and projected into the British National Grid (EPSG:27700). Northern Ireland is excluded due to its use of a separate national grid reference system.

---

## WIP - Visualisation

---

```{python}
import geopandas as gpd

lsoa = gpd.read_file(r"C:\Users\morri\PycharmProjects\shmers.github.io\geodata\Lower_layer_Super_Output_Areas_December_2021_Boundaries_EW_BGC_V5_-6970154227154374572.gpkg")

lsoa.head()
```
---
Reproject to BNG
---

```{python}
lsoa_bng = lsoa.to_crs(epsg=27700)

lsoa_bng.crs
```

---

LSOA boundary data are sourced from the UK Office for National Statistics Open Geography Portal and stored locally to ensure reproducibility. This avoids reliance on unstable external URLs while preserving authoritative geography under the Open Government Licence.

---

## Load population CSV

```{python}
pop = pd.read_csv(r"C:\Users\morri\PycharmProjects\shmers.github.io\geodata\Mid 2022 LSOA 2021.csv")
print(pop.columns.tolist())

pop.head()
```

---

## Extract relevant columns

```{python}
pop = pop.rename(columns={
    "LSOA 2021 Code": "LSOA21CD",
    "Total": "population"
})

pop = pop[["LSOA21CD", "population"]]

pop.head()
```

---
## Join population to LSOA geometry
---

```{python}
pop["population"] = (
    pop["population"]
    .str.replace(",", "", regex=False)
    .astype(int)
)

pop.dtypes
```

```{python}
lsoa = lsoa.merge(
    pop,
    on="LSOA21CD",
    how="left"
)

lsoa["population"].isna().mean()
```

---
## Project & Compute Population Density
---

```{python}

lsoa_bng = lsoa.to_crs(epsg=27700)

lsoa_bng["area_km2"] = lsoa_bng.geometry.area / 1e6
lsoa_bng["pop_density"] = (
    lsoa_bng["population"] / lsoa_bng["area_km2"]
)
```

---
## Plot Choropleth
---

```{python}
import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(9, 11))
ax.set_facecolor("#f0f0f0")

lsoa_bng.plot(
    ax=ax,
    column="pop_density",
    cmap="viridis",
    linewidth=0,
    legend=True,
    legend_kwds={
        "label": "Population density (people per km²)",
        "shrink": 0.6
    }
)

ax.set_title("Population Density by LSOA (Great Britain)")
ax.set_axis_off()
plt.show()
```